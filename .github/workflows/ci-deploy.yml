
name: CI – Deploy to AKS (with External IP wait + Smoke Test)

on:
  workflow_dispatch:
    inputs:
      imageTag:
        description: "Container image tag to deploy (e.g., commit SHA or 'latest')"
        required: true
        default: "latest"
      namespace:
        description: "Kubernetes namespace to deploy into"
        required: true
        default: "prod"

permissions:
  id-token: write
  contents: read

env:
  # ---- Azure + AKS configuration ----
  RESOURCE_GROUP: rg-docker-ci
  CLUSTER_NAME: mydockercls

  # ---- Container registry + image ----
  ACR_NAME: mydockeracrtst
  IMAGE_NAME: webapp

  # ---- Kubernetes manifests directory ----
  MANIFEST_DIR: k8s

  # ---- Service exposure options ----
  # Set to "true" to annotate the Service to use an existing static public IP.
  USE_STATIC_IP: "false"
  # Name of the public IP resource (Standard SKU) if using static IP.
  STATIC_IP_NAME: "myStaticIP"
  # Resource group of the public IP (often same as AKS RG; change if different).
  LB_RESOURCE_GROUP: "rg-docker-ci"
  # Optional DNS (if you later set Azure DNS or a custom DNS mapping to the static IP).
  FRIENDLY_HOSTNAME: ""   # e.g., "webapp.example.com"

jobs:
  deploy:
    runs-on: ubuntu-latest

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Azure Login (OIDC)
        uses: azure/login@v2
        with:
          client-id: ${{ secrets.AZURE_CLIENT_ID }}
          tenant-id: ${{ secrets.AZURE_TENANT_ID }}
          subscription-id: ${{ secrets.AZURE_SUBSCRIPTION_ID }}

      - name: Setup kubectl
        uses: azure/setup-kubectl@v3
        with:
          version: 'latest'

      - name: Resolve inputs and image reference
        id: vars
        run: |
          IMAGE_TAG="${{ github.event.inputs.imageTag || 'latest' }}"
          NAMESPACE="${{ github.event.inputs.namespace || 'prod' }}"
          IMAGE="${ACR_NAME}.azurecr.io/${IMAGE_NAME}:${IMAGE_TAG}"
          echo "IMAGE_TAG=$IMAGE_TAG" >> $GITHUB_OUTPUT
          echo "NAMESPACE=$NAMESPACE" >> $GITHUB_OUTPUT
          echo "IMAGE=$IMAGE" >> $GITHUB_OUTPUT
          echo "Resolved image: $IMAGE"
          echo "Namespace: $NAMESPACE"

      # --- Connect to AKS ---
      - name: Get AKS credentials
        run: |
          az aks get-credentials \
            --name "$CLUSTER_NAME" \
            --resource-group "$RESOURCE_GROUP" \
            --overwrite-existing
          kubectl cluster-info

      # --- Admin-secret approach: bypass RBAC/ABAC for pulls ---
      - name: Enable ACR admin user (idempotent)
        run: |
          az acr update -n "$ACR_NAME" --admin-enabled true

      - name: Create/Update imagePullSecret from ACR admin creds
        run: |
          USER=$(az acr credential show -n "$ACR_NAME" --query username -o tsv)
          PASS=$(az acr credential show -n "$ACR_NAME" --query passwords[0].value -o tsv)

          kubectl get ns "${{ steps.vars.outputs.NAMESPACE }}" >/dev/null 2>&1 || \
          kubectl create namespace "${{ steps.vars.outputs.NAMESPACE }}"

          kubectl delete secret acr-creds -n "${{ steps.vars.outputs.NAMESPACE }}" --ignore-not-found

          kubectl create secret docker-registry acr-creds \
            --docker-server="${ACR_NAME}.azurecr.io" \
            --docker-username="$USER" \
            --docker-password="$PASS" \
            -n "${{ steps.vars.outputs.NAMESPACE }}"

      # --- Apply app manifests ---
      - name: Validate manifests path exists
        run: |
          if [ ! -d "${MANIFEST_DIR}" ]; then
            echo "ERROR: Manifests directory '${MANIFEST_DIR}' not found in repo."
            exit 1
          fi

      - name: Apply Kubernetes manifests (Deployment/Service/etc.)
        run: |
          kubectl apply -n "${{ steps.vars.outputs.NAMESPACE }}" -f "${MANIFEST_DIR}"

      - name: Ensure Deployment uses imagePullSecrets=acr-creds
        run: |
          DEPLOYMENT_NAME="webapp"
          kubectl patch deployment "${DEPLOYMENT_NAME}" \
            -n "${{ steps.vars.outputs.NAMESPACE }}" \
            --type='strategic' \
            -p '{"spec":{"template":{"spec":{"imagePullSecrets":[{"name":"acr-creds"}]}}}}'

      - name: Set deployment image to requested tag
        run: |
          DEPLOYMENT_NAME="webapp"
          CONTAINER_NAME="webapp"
          kubectl set image deployment/${DEPLOYMENT_NAME} \
            ${CONTAINER_NAME}="${{ steps.vars.outputs.IMAGE }}" \
            -n "${{ steps.vars.outputs.NAMESPACE }}" \
            --record

      - name: Wait for rollout
        run: |
          kubectl rollout status deployment/webapp \
            -n "${{ steps.vars.outputs.NAMESPACE }}" \
            --timeout=300s

      # --- Expose Service as LoadBalancer (idempotent) ---
      - name: Ensure Service is LoadBalancer
        run: |
          # If Service exists, patch type; else create a minimal LoadBalancer Service.
          if kubectl get svc webapp -n "${{ steps.vars.outputs.NAMESPACE }}" >/dev/null 2>&1; then
            kubectl patch svc webapp -n "${{ steps.vars.outputs.NAMESPACE }}" --type='strategic' \
              -p '{"spec":{"type":"LoadBalancer","ports":[{"name":"http","port":80,"targetPort":8085}]}}'
          else
            cat <<'YAML' | kubectl apply -n "${{ steps.vars.outputs.NAMESPACE }}" -f -
            apiVersion: v1
            kind: Service
            metadata:
              name: webapp
            spec:
              type: LoadBalancer
              selector:
                app: webapp
              ports:
                - name: http
                  port: 80
                  targetPort: 8085
            YAML
          fi

      - name: (Optional) Annotate Service for static IP
        if: env.USE_STATIC_IP == 'true'
        run: |
          kubectl annotate svc webapp -n "${{ steps.vars.outputs.NAMESPACE }}" \
            "service.beta.kubernetes.io/azure-load-balancer-resource-group=${LB_RESOURCE_GROUP}" \
            "service.beta.kubernetes.io/azure-load-balancer-ip=${STATIC_IP_NAME}" \
            --overwrite

      # --- Wait for External IP ---
      - name: Wait for External IP
        id: wait_ip
        run: |
          echo "Waiting for External IP for Service 'webapp' in namespace '${{ steps.vars.outputs.NAMESPACE }}' ..."
          for i in {1..30}; do
            IP=$(kubectl get svc webapp -n "${{ steps.vars.outputs.NAMESPACE }}" -o jsonpath='{.status.loadBalancer.ingress[0].ip}')
            if [ -n "$IP" ]; then
              echo "External IP: $IP"
              echo "external_ip=$IP" >> $GITHUB_OUTPUT
              exit 0
            fi
            echo "Still pending... retrying in 10s"
            sleep 10
          done
          echo "❌ Timed out waiting for External IP"
          kubectl describe svc webapp -n "${{ steps.vars.outputs.NAMESPACE }}" || true
          exit 1

      # --- Smoke Test (HTTP 200) ---
      - name: Smoke Test (HTTP 200)
        run: |
          IP="${{ steps.wait_ip.outputs.external_ip }}"
          HOST="${{ env.FRIENDLY_HOSTNAME }}"
          URL="http://${IP}/"
          if [ -n "$HOST" ]; then
            # If you later map DNS to the static IP, also test hostname
            echo "Testing DNS host: http://${HOST}/"
          fi
          echo "Testing: ${URL}"
          for i in {1..10}; do
            STATUS=$(curl -s -o /dev/null -w "%{http_code}" "$URL")
            if [ "$STATUS" = "200" ]; then
              echo "✅ App is reachable at ${URL} (HTTP 200)"
              exit 0
            fi
            echo "Got $STATUS, retrying in 10s..."
            sleep 10
          done
          echo "❌ App did not return 200 OK from ${URL}"
          exit 1

      # --- Print URL / Output for downstream jobs ---
      - name: Output App URL
        id: appurl
        run: |
          echo "url=http://${{ steps.wait_ip.outputs.external_ip }}/" >> $GITHUB_OUTPUT
          echo "App URL: http://${{ steps.wait_ip.outputs.external_ip }}/"

      - name: Show resources
        run: |
          kubectl get deploy,rs,pods,svc,ingress -n "${{ steps.vars.outputs.NAMESPACE }}"
          echo "Deployed image: ${{ steps.vars.outputs.IMAGE }}"
          echo "App URL: http://${{ steps.wait_ip.outputs.external_ip }}/"
