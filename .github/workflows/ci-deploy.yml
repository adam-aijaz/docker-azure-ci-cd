
name: CI – Deploy to AKS (Admin Secret Pull)

on:
  workflow_dispatch:
    inputs:
      imageTag:
        description: "Container image tag to deploy (e.g., commit SHA or 'latest')"
        required: true
        default: "latest"
      namespace:
        description: "Kubernetes namespace to deploy into"
        required: true
        default: "prod"

permissions:
  id-token: write
  contents: read

env:
  RESOURCE_GROUP: rg-docker-ci
  CLUSTER_NAME: mydockercls
  ACR_NAME: mydockeracrtst
  IMAGE_NAME: webapp
  MANIFEST_DIR: k8s
  OPEN_AKS_API: "true"   # set to "true" if you want to clear authorized IP ranges automatically

jobs:
  deploy:
    runs-on: ubuntu-latest

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Azure Login (OIDC)
        uses: azure/login@v2
        with:
          client-id: ${{ secrets.AZURE_CLIENT_ID }}
          tenant-id: ${{ secrets.AZURE_TENANT_ID }}
          subscription-id: ${{ secrets.AZURE_SUBSCRIPTION_ID }}

      - name: Setup kubectl
        uses: azure/setup-kubectl@v3
        with:
          version: 'latest'

      - name: Resolve inputs and image reference
        id: vars
        run: |
          IMAGE_TAG="${{ github.event.inputs.imageTag || 'latest' }}"
          NAMESPACE="${{ github.event.inputs.namespace || 'prod' }}"
          IMAGE="${ACR_NAME}.azurecr.io/${IMAGE_NAME}:${IMAGE_TAG}"
          echo "IMAGE_TAG=$IMAGE_TAG" >> $GITHUB_OUTPUT
          echo "NAMESPACE=$NAMESPACE" >> $GITHUB_OUTPUT
          echo "IMAGE=$IMAGE" >> $GITHUB_OUTPUT
          echo "Resolved image: $IMAGE"
          echo "Namespace: $NAMESPACE"

      # ---------- Connectivity pre-check ----------
      - name: Check AKS API access settings
        run: |
          API_JSON=$(az aks show -g "$RESOURCE_GROUP" -n "$CLUSTER_NAME" --query apiServerAccessProfile -o json)
          echo "$API_JSON" | jq .
          ENABLE_PRIVATE=$(echo "$API_JSON" | jq -r '.enablePrivateCluster // empty')
          RANGES=$(echo "$API_JSON" | jq -r '.authorizedIpRanges | @csv')
          if [ "${ENABLE_PRIVATE}" = "true" ]; then
            echo "❌ AKS is PRIVATE. Public GitHub runner cannot reach the API. Use a VNet self-hosted runner or Cloud Shell in VNet."
            exit 1
          fi
          if [ -n "$RANGES" ] && [ "$RANGES" != "\"\"" ]; then
            echo "⚠️ AKS has Authorized IP ranges: $RANGES"
            echo "Runner may be blocked. Consider setting OPEN_AKS_API=true to clear ranges during CI."
          else
            echo "✅ No authorized IP ranges; API should be reachable."
          fi

      - name: (Optional) Temporarily open AKS API (clear authorized IP ranges)
        if: env.OPEN_AKS_API == 'true'
        run: |
          az aks update -g "$RESOURCE_GROUP" -n "$CLUSTER_NAME" --api-server-authorized-ip-ranges ""
          echo "✅ Cleared authorized IP ranges; AKS API is publicly reachable."

      - name: Get AKS credentials
        run: |
          az aks get-credentials --name "$CLUSTER_NAME" --resource-group "$RESOURCE_GROUP" --overwrite-existing
          kubectl cluster-info || (echo "❌ kubectl cannot reach AKS API. Check authorized IP ranges or private cluster settings."; exit 1)

      # ---------- Admin-secret approach ----------
      - name: Enable ACR admin user (idempotent)
        run: |
          az acr update -n "$ACR_NAME" --admin-enabled true

      - name: Create/Update imagePullSecret from ACR admin creds
        run: |
          USER=$(az acr credential show -n "$ACR_NAME" --query username -o tsv)
          PASS=$(az acr credential show -n "$ACR_NAME" --query passwords[0].value -o tsv)

          kubectl get ns "${{ steps.vars.outputs.NAMESPACE }}" >/dev/null 2>&1 || \
          kubectl create namespace "${{ steps.vars.outputs.NAMESPACE }}"

          kubectl delete secret acr-creds -n "${{ steps.vars.outputs.NAMESPACE }}" --ignore-not-found

          kubectl create secret docker-registry acr-creds \
            --docker-server="${ACR_NAME}.azurecr.io" \
            --docker-username="$USER" \
            --docker-password="$PASS" \
            -n "${{ steps.vars.outputs.NAMESPACE }}"

      - name: Validate manifests path exists
        run: |
          if [ ! -d "${MANIFEST_DIR}" ]; then
            echo "ERROR: Manifests directory '${MANIFEST_DIR}' not found in repo."
            exit 1
          fi

      - name: Apply Kubernetes manifests
        run: |
          kubectl apply -n "${{ steps.vars.outputs.NAMESPACE }}" -f "${MANIFEST_DIR}"

      - name: Ensure Deployment uses imagePullSecrets=acr-creds
        run: |
          DEPLOYMENT_NAME="webapp"
          kubectl patch deployment "${DEPLOYMENT_NAME}" \
            -n "${{ steps.vars.outputs.NAMESPACE }}" \
            --type='strategic' \
            -p '{"spec":{"template":{"spec":{"imagePullSecrets":[{"name":"acr-creds"}]}}}}'

      - name: Set deployment image to requested tag
        run: |
          DEPLOYMENT_NAME="webapp"
          CONTAINER_NAME="webapp"
          kubectl set image deployment/${DEPLOYMENT_NAME} \
            ${CONTAINER_NAME}="${{ steps.vars.outputs.IMAGE }}" \
            -n "${{ steps.vars.outputs.NAMESPACE }}" \
            --record

      - name: Wait for rollout
        run: |
          kubectl rollout status deployment/webapp \
            -n "${{ steps.vars.outputs.NAMESPACE }}" \
            --timeout=300s

      - name: Show resources
        run: |
          kubectl get deploy,rs,pods,svc,ingress -n "${{ steps.vars.outputs.NAMESPACE }}"
          echo "Deployed image: ${{ steps.vars.outputs.IMAGE }}"

      - name: Diagnostics (if pods failing)
        if: failure()
        run: |
          kubectl get events -n "${{ steps.vars.outputs.NAMESPACE }}" --sort-by=.lastTimestamp | tail -n 100
          for p in $(kubectl get pods -n "${{ steps.vars.outputs.NAMESPACE }}" -o jsonpath='{.items[*].metadata.name}'); do
            echo "---- Describe $p ----"
            kubectl describe pod "$p" -n "${{ steps.vars.outputs.NAMESPACE }}" || true
            echo "---- Logs (webapp) $p ----"
            kubectl logs "$p" -n "${{ steps.vars.outputs.NAMESPACE }}" --container webapp --tail=200 || true
            echo "---- Previous Logs (webapp) $p ----"
            kubectl logs "$p" -n "${{ steps.vars.outputs.NAMESPACE }}" --container webapp --previous --tail=200 || true
